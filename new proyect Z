--// SLX ULTIMATE - PREMIUM GHOST EDITION (ULTRA COMPACT & MODULES) //--
--// "EL HUB MÁS PERRO Y COMPACTO DEL MERCADO - SLX BLACK TECH" //--
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")
local Stats = game:GetService("Stats")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

--// CONFIGURACIÓN DE TEMA PREMIUM //--
local T = {
    Main = Color3.fromRGB(10, 10, 15),
    Side = Color3.fromRGB(15, 15, 22),
    Acc = Color3.fromRGB(0, 255, 255), 
    Acc2 = Color3.fromRGB(85, 0, 255), 
    NeonRed = Color3.fromRGB(255, 0, 50), 
    Text = Color3.fromRGB(255, 255, 255),
    DimText = Color3.fromRGB(180, 180, 180),
    Font = Enum.Font.GothamBold,
    FontMid = Enum.Font.GothamMedium,
    Trans = 0.25 
}

-- Cleanup previo
if PlayerGui:FindFirstChild("SLX_PREMIUM_GHOST") then 
    PlayerGui.SLX_PREMIUM_GHOST:Destroy() 
end

local Screen = Instance.new("ScreenGui", PlayerGui)
Screen.Name = "SLX_PREMIUM_GHOST"
Screen.ResetOnSpawn = false
Screen.IgnoreGuiInset = true

--// ========================================== //--
--//        MOTOR GLOBAL RAINBOW + ESP          //--
--// ========================================== //--

_G.Rainbow_Enabled = false
_G.Global_Rainbow_Color = Color3.fromRGB(0, 255, 255)

-- Hilo Maestro del Color (No lo toques, esto hace la magia)
task.spawn(function()
    local counter = 0
    while true do
        counter = counter + 0.01
        if _G.Rainbow_Enabled then
            _G.Global_Rainbow_Color = Color3.fromHSV(counter % 1, 0.7, 1)
        else
            _G.Global_Rainbow_Color = Color3.fromRGB(0, 255, 255)
        end
        task.wait(0.01) -- Velocidad del cambio de color
    end
end)

--// MOTOR ESP GHOST (FORZADO RANGO MÁXIMO) //--
_G.ESP_Enabled = false 

local function AsegurarHighlight(player)
    if player == game.Players.LocalPlayer then return end
    
    local char = player.Character
    if not char then return end
    
    -- Buscamos si ya tiene el ESP
    local highlight = char:FindFirstChild("SLX_ESP")
    
    if _G.ESP_Enabled then
        if not highlight then
            highlight = Instance.new("Highlight")
            highlight.Name = "SLX_ESP"
            highlight.Adornee = char -- Forzamos el objetivo
            -- SIEMPRE VISIBLE: DepthMode 'AlwaysOnTop' es clave
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop 
            highlight.FillTransparency = 0.5
            highlight.OutlineTransparency = 0 -- Borde marcado para ver de lejos
            highlight.Parent = char
        end
        
        highlight.Enabled = true
        highlight.FillColor = _G.Global_Rainbow_Color
        highlight.OutlineColor = _G.Rainbow_Enabled and _G.Global_Rainbow_Color or Color3.fromRGB(255, 255, 255)
        
        -- TRUCO PARA DISTANCIA: Forzar que el motor lo renderice
        -- Si está muy lejos, Roblox intenta apagarlo. Esto lo mantiene despierto.
        if highlight.Adornee == nil then highlight.Adornee = char end
    else
        if highlight then
            highlight:Destroy()
        end
    end
end

-- Bucle de Escaneo (Se mantiene igual para no dar lag)
task.spawn(function()
    while true do
        for _, p in pairs(game.Players:GetPlayers()) do
            pcall(function()
                AsegurarHighlight(p)
            end)
        end
        task.wait(0.5) 
    end
end)

--// 2. MOTOR ESP 2D (ESTE SIEMPRE SE VE A CUALQUIER DISTANCIA) //--
_G.ESP_2D_Enabled = false

local function AplicarESP2D(player)
    if player == game.Players.LocalPlayer then return end
    
    local function addStuff(char)
        if not char then return end
        local hrp = char:WaitForChild("HumanoidRootPart", 10)
        if not hrp then return end
        
        if hrp:FindFirstChild("SLX_Box") then hrp.SLX_Box:Destroy() end

        local box = Instance.new("BillboardGui", hrp)
        box.Name = "SLX_Box"
        box.AlwaysOnTop = true 
        -- Al ser BillboardGui, se ve a CUALQUIER distancia si no le pones límite
        box.MaxDistance = math.huge -- <--- ESTO ES PARA DISTANCIA INFINITA
        box.Size = UDim2.new(4.5, 0, 6, 0)
        
        local frame = Instance.new("Frame", box)
        frame.Size = UDim2.new(1, 0, 1, 0)
        frame.BackgroundTransparency = 1
        
        local stroke = Instance.new("UIStroke", frame)
        stroke.Thickness = 1.5
        stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border

        task.spawn(function()
            while char and char.Parent and box and box.Parent do
                box.Enabled = _G.ESP_2D_Enabled
                if _G.ESP_2D_Enabled then
                    stroke.Color = _G.Global_Rainbow_Color
                end
                task.wait(0.03)
            end
        end)
    end
    
    player.CharacterAdded:Connect(addStuff)
    if player.Character then task.spawn(function() addStuff(player.Character) end) end
end

for _, p in pairs(game.Players:GetPlayers()) do AplicarESP2D(p) end
game.Players.PlayerAdded:Connect(AplicarESP2D)

--// MOTOR TRACERS 360 MAESTRO (INMORTAL - NO RESET AL MORIR) //--
_G.Tracers_Enabled = false

-- Función para crear o recuperar la carpeta maestra
local function ObtenerCarpetaMaestra()
    local gui = game.Players.LocalPlayer.PlayerGui:FindFirstChild("Master_Tracers")
    if not gui then
        gui = Instance.new("ScreenGui")
        gui.Name = "Master_Tracers"
        gui.IgnoreGuiInset = true
        gui.ResetOnSpawn = false -- <--- AQUÍ ESTÁ EL TRUCO: No se borra al morir tú
        gui.DisplayOrder = 999
        gui.Parent = game.Players.LocalPlayer.PlayerGui
    end
    return gui
end

local function ObtenerTracer(player)
    local folder = ObtenerCarpetaMaestra()
    local name = "Line_" .. player.Name
    local line = folder:FindFirstChild(name)
    if not line then
        line = Instance.new("Frame")
        line.Name = name
        line.BorderSizePixel = 0
        line.AnchorPoint = Vector2.new(0.5, 0.5)
        line.Visible = false
        line.Parent = folder
    end
    return line
end

game:GetService("RunService").RenderStepped:Connect(function()
    -- Validamos la carpeta en cada frame por si acaso
    local folder = ObtenerCarpetaMaestra()
    
    for _, player in pairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            local line = ObtenerTracer(player)
            local char = player.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            local hum = char and char:FindFirstChild("Humanoid")

            if _G.Tracers_Enabled and hrp and hum and hum.Health > 0 then
                local cam = workspace.CurrentCamera
                local startPos = Vector2.new(cam.ViewportSize.X / 2, cam.ViewportSize.Y)
                local screenPoint, onScreen = cam:WorldToViewportPoint(hrp.Position)
                local endPos = Vector2.new(screenPoint.X, screenPoint.Y)

                -- LÓGICA 360 REAL
                if screenPoint.Z < 0 then
                    local invPos = (Vector2.new(screenPoint.X, screenPoint.Y) - Vector2.new(cam.ViewportSize.X/2, cam.ViewportSize.Y/2)).Unit * 1000
                    endPos = Vector2.new(cam.ViewportSize.X/2, cam.ViewportSize.Y/2) - invPos
                end

                local finalEndPos = Vector2.new(math.clamp(endPos.X, 0, cam.ViewportSize.X), math.clamp(endPos.Y, 0, cam.ViewportSize.Y))
                
                line.Visible = true
                line.Size = UDim2.new(0, (startPos - finalEndPos).Magnitude, 0, 1.2)
                line.Position = UDim2.new(0, (startPos.X + finalEndPos.X) / 2, 0, (startPos.Y + finalEndPos.Y) / 2)
                line.Rotation = math.deg(math.atan2(finalEndPos.Y - startPos.Y, finalEndPos.X - startPos.X))
                line.BackgroundColor3 = _G.Global_Rainbow_Color
            else
                if line then line.Visible = false end
            end
        end
    end
end)

-- Limpieza al salir un jugador
game.Players.PlayerRemoving:Connect(function(player)
    local folder = game.Players.LocalPlayer.PlayerGui:FindFirstChild("Master_Tracers")
    if folder then
        local line = folder:FindFirstChild("Line_" .. player.Name)
        if line then line:Destroy() end
    end
end)

--// MOTOR NVG PROFESIONAL (SIERRA STYLE) //--
_G.NightVision_Enabled = false

local Lighting = game:GetService("Lighting")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Creamos el efecto exacto del script que pasaste
local NVG_Effect = Lighting:FindFirstChild("ColornvgSierraMX") or Instance.new("ColorCorrectionEffect", Lighting)
NVG_Effect.Name = "ColornvgSierraMX"
NVG_Effect.Enabled = false

-- Guardar atmósfera original
local Atmosphere = Lighting:FindFirstChildOfClass("Atmosphere")

task.spawn(function()
    while task.wait(0.5) do
        if _G.NightVision_Enabled then
            -- 1. Quitar niebla/atmósfera como el script pro
            if Atmosphere and Atmosphere.Parent == Lighting then
                Atmosphere.Parent = ReplicatedStorage
            end
            
            -- 2. Configuración de Iluminación Sierra
            Lighting.ExposureCompensation = 3 -- Sube la exposición para ver en lo oscuro
            NVG_Effect.Enabled = true
            NVG_Effect.Brightness = 0.1
            NVG_Effect.Contrast = 0.8
            NVG_Effect.Saturation = -1 -- Lo hace blanco y negro/verde
            NVG_Effect.TintColor = Color3.new(0, 1, 0) -- El verde exacto
        else
            -- 3. Restaurar todo al estado original
            if Atmosphere and Atmosphere.Parent == ReplicatedStorage then
                Atmosphere.Parent = Lighting
            end
            
            Lighting.ExposureCompensation = 0
            NVG_Effect.Enabled = false
            NVG_Effect.TintColor = Color3.new(1, 1, 1)
            NVG_Effect.Saturation = 0
            NVG_Effect.Contrast = 0
        end
    end
end)

--// ========================================== //--
--//    ESP TÁCTICO (SISTEMA ESCLAVO RAINBOW)    //--
--// ========================================== //--

_G.ESP_Text_Enabled = false

local function AplicarESPTexto(player)
    if player == LocalPlayer then return end
    
    local function addStuff(char)
        if not char then return end
        local head = char:WaitForChild("Head", 10)
        if not head then return end
        
        if head:FindFirstChild("TacticESP") then head.TacticESP:Destroy() end

        local billboard = Instance.new("BillboardGui", head)
        billboard.Name = "TacticESP"; billboard.AlwaysOnTop = true
        billboard.Size = UDim2.new(0, 200, 0, 50); billboard.StudsOffset = Vector3.new(0, 3, 0)
        
        local label = Instance.new("TextLabel", billboard)
        label.Name = "InfoLabel"; label.Size = UDim2.new(1, 0, 1, 0)
        label.BackgroundTransparency = 1; label.TextStrokeTransparency = 0
        label.TextSize = 14; label.Font = Enum.Font.RobotoMono
        label.TextColor3 = Color3.new(1, 1, 1)

        task.spawn(function()
            while char and char.Parent and billboard.Parent do
                billboard.Enabled = _G.ESP_Text_Enabled
                
                if _G.ESP_Text_Enabled then
                    -- Actualizar Distancia
                    local targetHrp = char:FindFirstChild("HumanoidRootPart")
                    local myHrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                    
                    if targetHrp and myHrp then
                        local dist = math.floor((myHrp.Position - targetHrp.Position).Magnitude)
                        label.Text = "|  " .. player.Name .. "  |  Rango " .. dist .. " m  |"
                    end

                    --// LÓGICA DE COLOR FORZADA //--
                    if _G.Rainbow_Enabled == true then
                        -- Si el rainbow está activo, NO importa el equipo, usa tu color
                        label.TextColor3 = _G.Global_Rainbow_Color
                    else
                        -- Si está apagado, vuelve a color de equipo
                        if player.TeamColor == LocalPlayer.TeamColor then
                            label.TextColor3 = Color3.fromRGB(0, 255, 0)
                        else
                            label.TextColor3 = Color3.fromRGB(255, 0, 0)
                        end
                    end
                end
                task.wait(0.03) -- Sincronizado con tus otros módulos
            end
        end)
    end

    player.CharacterAdded:Connect(addStuff)
    if player.Character then addStuff(player.Character) end
end

for _, p in pairs(game.Players:GetPlayers()) do AplicarESPTexto(p) end
game.Players.PlayerAdded:Connect(AplicarESPTexto)

--// ========================================== //--
--//      MOTOR HITBOX MODO DIOS (NO BLIND SPOTS)   //--
--// ========================================== //--

_G.Hitbox_Enabled = false
_G.Hitbox_Size = 10 

task.spawn(function()
    while true do
        for _, p in pairs(game.Players:GetPlayers()) do
            if p ~= LocalPlayer and p.Character then
                pcall(function()
                    local char = p.Character
                    local head = char:FindFirstChild("Head")
                    local hum = char:FindFirstChild("Humanoid")
                    
                    if head and hum and hum.Health > 0 then
                        if _G.Hitbox_Enabled then
                            -- FORZADO DE REGISTRO DE IMPACTO --
                            if head.Size.Y ~= _G.Hitbox_Size then
                                head.Size = Vector3.new(_G.Hitbox_Size, _G.Hitbox_Size, _G.Hitbox_Size)
                                
                                -- Cambiamos la forma a Ball para que el registro sea circular y total
                                -- O la dejamos por defecto pero quitamos el offset
                                head.Transparency = 0.6
                                head.Color = _G.Global_Rainbow_Color
                                head.CanCollide = false
                                head.Massless = true
                                
                                -- FIX PARA EL PUNTO CIEGO:
                                -- Forzamos que la cabeza no se mueva por animaciones (la "anclamos" visualmente al centro)
                                if head:FindFirstChildOfClass("SpecialMesh") then
                                    head:FindFirstChildOfClass("SpecialMesh").Scale = Vector3.new(1,1,1)
                                end
                            end
                        else
                            -- RESET TOTAL
                            if head.Size.Y ~= 1.2 then
                                head.Size = Vector3.new(1.2, 1.2, 1.2)
                                head.Transparency = 0
                                head.CanCollide = true
                                head.Massless = false
                            end
                        end
                    end
                end)
            end
        end
        task.wait(0.1)
    end
end)

--// MOTOR DE PARTÍCULAS (BOLITAS ROJAS) //--
local function StartParticleEngine(parent)
    task.spawn(function()
        while parent and parent.Parent do
            if parent.Visible and parent.BackgroundTransparency < 1 then
                local p = Instance.new("Frame")
                p.Name = "Particle"
                p.Size = UDim2.new(0, math.random(3, 5), 0, math.random(3, 5))
                local startY = math.random(0, 100) / 100
                p.Position = UDim2.new(math.random(0, 100) / 100, 0, startY, 0)
                p.BackgroundColor3 = T.NeonRed
                p.BackgroundTransparency = 0.4
                p.BorderSizePixel = 0
                p.ZIndex = 1
                p.Parent = parent
                Instance.new("UICorner", p).CornerRadius = UDim.new(1, 0)
                local stroke = Instance.new("UIStroke", p)
                stroke.Color = T.NeonRed; stroke.Thickness = 1; stroke.Transparency = 0.6
                local targetY = (startY > 0.5) and -0.2 or 1.2
                local duration = math.random(3, 6)
                TweenService:Create(p, TweenInfo.new(duration, Enum.EasingStyle.Linear), {
                    Position = UDim2.new(p.Position.X.Scale, 0, targetY, 0),
                    BackgroundTransparency = 1
                }):Play()
                Debris:AddItem(p, duration)
            end
            task.wait(0.4)
        end
    end)
end

--// FUNCIONES DE INTERFAZ //--
local function RippleEffect(obj)
    obj.MouseButton1Click:Connect(function()
        local r = Instance.new("Frame", obj)
        r.BackgroundColor3 = Color3.new(1, 1, 1); r.BackgroundTransparency = 0.8
        r.Size = UDim2.new(0, 0, 0, 0); r.Position = UDim2.new(0.5, 0, 0.5, 0)
        r.AnchorPoint = Vector2.new(0.5, 0.5); r.ZIndex = 10
        Instance.new("UICorner", r).CornerRadius = UDim.new(1, 0)
        TweenService:Create(r, TweenInfo.new(0.5, Enum.EasingStyle.OutExpo), {
            Size = UDim2.new(2, 0, 3, 0), BackgroundTransparency = 1
        }):Play()
        Debris:AddItem(r, 0.5)
    end)
end

local function MakeDraggable(obj)
    local drag, startPos, dragStart
    obj.InputBegan:Connect(function(i)
        if i.UserInputType == Enum.UserInputType.MouseButton1 or i.UserInputType == Enum.UserInputType.Touch then
            drag = true; dragStart = i.Position; startPos = obj.Position
        end
    end)
    UserInputService.InputChanged:Connect(function(i)
        if drag and (i.UserInputType == Enum.UserInputType.MouseMovement or i.UserInputType == Enum.UserInputType.Touch) then
            local delta = i.Position - dragStart
            obj.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
    obj.InputEnded:Connect(function(i)
        if i.UserInputType == Enum.UserInputType.MouseButton1 or i.UserInputType == Enum.UserInputType.Touch then drag = false end
    end)
end

--// MAIN UI (POSICIONADO ABAJO PARA LA ANIMACIÓN) //--
local Main = Instance.new("Frame", Screen)
Main.Name = "Main"
Main.Size = UDim2.new(0, 380, 0, 240)
Main.Position = UDim2.new(0.5, -190, 1.5, 0) -- Fuera de pantalla abajo
Main.BackgroundColor3 = T.Main
Main.BackgroundTransparency = T.Trans
Main.ClipsDescendants = true
Instance.new("UICorner", Main).CornerRadius = UDim.new(0, 12)
local MainStroke = Instance.new("UIStroke", Main)
MainStroke.Thickness = 2; MainStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
local MainGrad = Instance.new("UIGradient", MainStroke)
MainGrad.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, T.Acc), ColorSequenceKeypoint.new(1, T.Acc2)}

MakeDraggable(Main)
StartParticleEngine(Main)

-- Sidebar
local Side = Instance.new("Frame", Main)
Side.Name = "Side"
Side.Size = UDim2.new(0, 100, 1, 0)
Side.BackgroundColor3 = T.Side; Side.BackgroundTransparency = 0.3; Side.BorderSizePixel = 0; Side.ZIndex = 2

-- User Info
local User = Instance.new("Frame", Side)
User.Size = UDim2.new(1, 0, 0, 80); User.Position = UDim2.new(0, 0, 1, -85); User.BackgroundTransparency = 1; User.ZIndex = 3
local Pfp = Instance.new("ImageLabel", User)
Pfp.Size = UDim2.new(0, 40, 0, 40); Pfp.Position = UDim2.new(0.5, -20, 0, 5); Pfp.BackgroundColor3 = T.Main
Pfp.Image = Players:GetUserThumbnailAsync(LocalPlayer.UserId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size100x100)
Pfp.ZIndex = 4; Instance.new("UICorner", Pfp).CornerRadius = UDim.new(1, 0)
local PStroke = Instance.new("UIStroke", Pfp); PStroke.Color = T.Acc; PStroke.Thickness = 1.5
local StatsLbl = Instance.new("TextLabel", User)
StatsLbl.Size = UDim2.new(1, 0, 0, 30); StatsLbl.Position = UDim2.new(0, 0, 0, 50); StatsLbl.BackgroundTransparency = 1
StatsLbl.Font = T.FontMid; StatsLbl.TextSize = 9; StatsLbl.TextColor3 = T.DimText; StatsLbl.Text = "FPS: ... | MS: ..."; StatsLbl.ZIndex = 4

--// CONTENEDOR DE PÁGINAS //--
local Pages = {}
local Content = Instance.new("Frame", Main)
Content.Name = "Content"
Content.Size = UDim2.new(1, -115, 1, -45)
Content.Position = UDim2.new(0, 110, 0, 40)
Content.BackgroundTransparency = 1; Content.ZIndex = 2

local function CreatePage(name)
    local pf = Instance.new("ScrollingFrame", Content)
    pf.Name = name.."_Page"
    pf.Size = UDim2.new(1, 0, 1, 0)
    pf.BackgroundTransparency = 1
    pf.ScrollBarThickness = 0
    pf.Visible = false
    pf.CanvasSize = UDim2.new(0, 0, 0, 0)
    
    local layout = Instance.new("UIListLayout", pf)
    layout.SortOrder = Enum.SortOrder.LayoutOrder
    layout.Padding = UDim.new(0, 6)
    
    Pages[name] = pf
    return pf
end

--// COMPONENTE TOGGLE PREMIUM //--
local function AddToggle(page, title, callback)
    local tFrame = Instance.new("Frame", page)
    tFrame.Size = UDim2.new(1, -5, 0, 35)
    tFrame.BackgroundColor3 = T.Side
    tFrame.BackgroundTransparency = 0.5
    Instance.new("UICorner", tFrame).CornerRadius = UDim.new(0, 6)
    
    local tLabel = Instance.new("TextLabel", tFrame)
    tLabel.Text = "  "..title
    tLabel.Size = UDim2.new(1, -40, 1, 0)
    tLabel.BackgroundTransparency = 1
    tLabel.TextColor3 = T.DimText
    tLabel.Font = T.FontMid
    tLabel.TextSize = 11
    tLabel.TextXAlignment = "Left"
    
    local switchBg = Instance.new("Frame", tFrame)
    switchBg.Size = UDim2.new(0, 30, 0, 16)
    switchBg.Position = UDim2.new(1, -35, 0.5, -8)
    switchBg.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    Instance.new("UICorner", switchBg).CornerRadius = UDim.new(1, 0)
    
    local dot = Instance.new("Frame", switchBg)
    dot.Size = UDim2.new(0, 12, 0, 12)
    dot.Position = UDim2.new(0, 2, 0.5, -6)
    dot.BackgroundColor3 = Color3.fromRGB(200, 200, 200)
    Instance.new("UICorner", dot).CornerRadius = UDim.new(1, 0)
    
    local btn = Instance.new("TextButton", tFrame)
    btn.Size = UDim2.new(1, 0, 1, 0); btn.BackgroundTransparency = 1; btn.Text = ""
    
    local enabled = false
    btn.MouseButton1Click:Connect(function()
        enabled = not enabled
        local targetPos = enabled and UDim2.new(1, -14, 0.5, -6) or UDim2.new(0, 2, 0.5, -6)
        local targetCol = enabled and T.Acc or Color3.fromRGB(200, 200, 200)
        local bgCol = enabled and Color3.fromRGB(0, 100, 100) or Color3.fromRGB(40, 40, 50)
        
        TweenService:Create(dot, TweenInfo.new(0.3), {Position = targetPos, BackgroundColor3 = targetCol}):Play()
        TweenService:Create(switchBg, TweenInfo.new(0.3), {BackgroundColor3 = bgCol}):Play()
        TweenService:Create(tLabel, TweenInfo.new(0.3), {TextColor3 = enabled and T.Text or T.DimText}):Play()
        
        callback(enabled)
    end)
    page.CanvasSize = UDim2.new(0, 0, 0, (page:FindFirstChildOfClass("UIListLayout").AbsoluteContentSize.Y + 10))
end

--// COMPONENTE INPUT DE TECLADO (TAMAÑO HITBOX) //--
local function AddHitboxInput(page, title)
    local iFrame = Instance.new("Frame", page)
    iFrame.Size = UDim2.new(1, -5, 0, 35)
    iFrame.BackgroundColor3 = T.Side
    iFrame.BackgroundTransparency = 0.5
    Instance.new("UICorner", iFrame).CornerRadius = UDim.new(0, 6)
    
    local iLabel = Instance.new("TextLabel", iFrame)
    iLabel.Text = "  "..title
    iLabel.Size = UDim2.new(1, -50, 1, 0)
    iLabel.BackgroundTransparency = 1
    iLabel.TextColor3 = T.DimText
    iLabel.Font = T.FontMid; iLabel.TextSize = 11; iLabel.TextXAlignment = "Left"
    
    local box = Instance.new("TextBox", iFrame)
    box.Size = UDim2.new(0, 40, 0, 22)
    box.Position = UDim2.new(1, -45, 0.5, -11)
    box.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
    box.TextColor3 = T.Acc -- El color cyan de tu Hub
    box.Text = tostring(_G.Hitbox_Size or 10)
    box.Font = T.Font; box.TextSize = 12
    box.ClearTextOnFocus = true -- Para que no tengas que borrar el número anterior
    Instance.new("UICorner", box)
    
    -- Al dar Enter o perder el foco
    box.FocusLost:Connect(function(enterPressed)
        local val = tonumber(box.Text)
        if val then
            val = math.clamp(val, 1, 100) -- Limite 1 a 100
            _G.Hitbox_Size = val
            box.Text = tostring(val)
            print("Nuevo Hitbox Size: "..val)
        else
            box.Text = tostring(_G.Hitbox_Size) -- Si pone letras, regresa al anterior
        end
    end)
end

--// CREACIÓN DE PÁGINAS //--
local CombatPage = CreatePage("COMBAT")
local VisualPage = CreatePage("VISUALS")
local MiscPage = CreatePage("MISC")

-- Visuals
AddToggle(VisualPage, "ACTIVE RAINBOW", function(v) _G.Rainbow_Enabled = v end)
AddToggle(VisualPage, "GHOST ESP", function(v) _G.ESP_Enabled = v end)
AddToggle(VisualPage, "BOX ESP", function(v) _G.ESP_2D_Enabled = v end)
AddToggle(VisualPage, "ESP NOMBRES / DISTANCIA", function(v) _G.ESP_Text_Enabled = v end)
AddToggle(VisualPage, "PLAYER TRACERS", function(v) _G.Tracers_Enabled = v end)
AddToggle(VisualPage, "NIGHT VISION v1", function(v) _G.NightVision_Enabled = v end)

-- Combat
AddToggle(CombatPage, "BIG HEAD HITBOX (10x)", function(v)  _G.Hitbox_Enabled = v end)
-- Llamada en el menú:
AddHitboxInput(CombatPage, "AJUSTAR HITBOX (ESCRIBIR)")

--// TAB SYSTEM LOGIC //--
local function CreateTab(name, pos, page)
    local b = Instance.new("TextButton", Side)
    b.Size = UDim2.new(0.85, 0, 0, 28); b.Position = UDim2.new(0.07, 0, 0, pos)
    b.BackgroundColor3 = T.Main; b.BackgroundTransparency = 0.5; b.Text = name
    b.Font = T.FontMid; b.TextSize = 11; b.TextColor3 = T.DimText; b.ZIndex = 5
    Instance.new("UICorner", b).CornerRadius = UDim.new(0, 6)
    RippleEffect(b)
    
    if page == CombatPage then 
        b.TextColor3 = T.Acc; b.BackgroundTransparency = 0.2; page.Visible = true
    end

    b.MouseButton1Click:Connect(function()
        for _, v in pairs(Side:GetChildren()) do
            if v:IsA("TextButton") then TweenService:Create(v, TweenInfo.new(0.3), {TextColor3 = T.DimText, BackgroundTransparency = 0.5}):Play() end
        end
        for _, p in pairs(Pages) do p.Visible = false end
        TweenService:Create(b, TweenInfo.new(0.3), {TextColor3 = T.Acc, BackgroundTransparency = 0.2}):Play()
        page.Visible = true
    end)
end

CreateTab("COMBAT", 45, CombatPage)
CreateTab("VISUALS", 78, VisualPage)
CreateTab("MISC", 111, MiscPage)

-- Header & Title
local Title = Instance.new("TextLabel", Main)
Title.Text = "SLX ULTIMATE"; Title.Font = T.Font; Title.TextSize = 14; Title.TextColor3 = T.Text; Title.Position = UDim2.new(0, 12, 0, 10); Title.Size = UDim2.new(0, 150, 0, 20); Title.BackgroundTransparency = 1; Title.TextXAlignment = "Left"; Title.ZIndex = 10

-- Botón Minimizar
local MinBtn = Instance.new("TextButton", Main)
MinBtn.Size = UDim2.new(0, 24, 0, 24); MinBtn.Position = UDim2.new(1, -32, 0, 8); MinBtn.BackgroundColor3 = T.Side; MinBtn.Text = "-"; MinBtn.Font = T.Font; MinBtn.TextSize = 16; MinBtn.TextColor3 = T.Acc; MinBtn.ZIndex = 11; Instance.new("UICorner", MinBtn)

local isMin = false
MinBtn.MouseButton1Click:Connect(function()
    isMin = not isMin
    if isMin then
        TweenService:Create(Main, TweenInfo.new(0.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Size = UDim2.new(0, 380, 0, 40), BackgroundTransparency = 0.1}):Play()
        Side.Visible = false; Content.Visible = false; MinBtn.Text = "+"
    else
        TweenService:Create(Main, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {Size = UDim2.new(0, 380, 0, 240), BackgroundTransparency = T.Trans}):Play()
        task.wait(0.1); Side.Visible = true; Content.Visible = true; MinBtn.Text = "-"
    end
end)

-- Stats Loop
task.spawn(function()
    while true do
        local fps = math.floor(1/RunService.RenderStepped:Wait())
        local ping = math.floor(Stats.Network.ServerStatsItem["Data Ping"]:GetValue())
        StatsLbl.Text = "FPS: "..fps.." | MS: "..ping; task.wait(0.5)
    end
end)

--// ANIMACIÓN DE ENTRADA (DE ABAJO AL CENTRO) //--
task.spawn(function()
    -- Esperamos un poco para asegurar que todo cargue internamente
    task.wait(0.1)
    -- El Hub se desliza desde el fondo (1.5 de escala Y) hasta el centro (0.5)
    TweenService:Create(Main, TweenInfo.new(1.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        Position = UDim2.new(0.5, -190, 0.5, -120)
    }):Play()
end)
